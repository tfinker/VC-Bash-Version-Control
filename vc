#!/bin/bash

if [[ $# -eq 0 ]];
then
	echo "No parameters provided"
	exit 0
fi

function add {
	echo 'add function'

	if [[ -z $1 ]]; then
		echo "Add: No file provided"
		exit 0
	fi

	if [[ ! -f $1 ]]; then
		echo "Add: File '$1' doesn't exist"
		exit 0
	fi

	if [[ ! -d '.staging' ]]; then
		mkdir './.staging'
	fi
	cp $1 ./.staging/

}

function list {
	echo 'list function'

	if [[ -d './.staging' ]]; then
		echo "---------- Files in staging: ----------"	
		ls ./.staging
		echo "---------- End files in staging: ----------"	
	else
		echo "No files in staging"
	fi

	if [[ -d './.commit' ]]; then
		echo "---------- Committed files: ----------"	
		ls ./.commit
		echo "---------- End Committed files: ----------"	
	else
		echo "No committed files"
	fi
	

}

function commit {
	echo 'commit function'

	if [[ -z $1 ]]; then
		echo "Commit: no message provided"
		exit 0
	fi
	
	# commitDate=$(date)
	# echo $commitDate
	mkdir -p ./.commit/ 

	# get list of files in staging
	# individually compare with those in .commit
	# if same filename, run merge function
	# otherwise copy file to .commit

	stagingfiles=($(ls .staging))
	commitfiles=($(ls .commit))
	echo ${stagingfiles[@]}
	echo ${commitfiles[@]}

	for file in ${stagingfiles[@]}
	do
		echo $file
		if [[ -f .commit/$file ]]; then
			merge $file
		else
			cp .staging/$file .commit
		fi
	done
	#echo "Commit date: "$commitDate > ./.commit/.commitInfo
	#echo "Message: "$1 >> ./.commit/.commitInfo
	#chmod 444 ./.commit/*
	#rm -r ./.staging
}

function merge {
	echo 'merging '$1
	echo 'File "'$1'" already exists in repository'
	# handle if file is identical
	read -p 'Do you want to overwrite (1) or merge (2)? ' userAction
	case $userAction in
		"1")
			cp $1 .commit
			;;
		"2")
			cp .staging/$1 .commit/.$1.merging
			compare=$(diff -q .commit/.$1.merging .commit/$1)
			echo $compare
			while [[ $compare != ""  ]]; do
				diff ".commit/$1" ".commit/.$1.merging" | awk -f awkdiff
				mergeAction=$(sed "1q;d" .commit/.action.merge)
				echo $mergeAction		
				blockMerge $1 $mergeAction
#				rm .commit/$1.changes
				compare=$(diff -q .commit/.$1.merging .commit/$1)
				break
			done	
			;;
		*)
			echo 'wrong action entered'
			;;
	esac

}


function blockMerge {
	case $2 in
		"a")
			finishLocs=($(sed -n "1,2p" .commit/.finish.merge))
			if [[ ${finishLocs[0]} -le 1 ]]; then
				startView=1
			else
				startView=$(( ${finishLocs[0]}-1 ))
			fi
			endView=$(( ${finishLocs[1]}+1 )) 
			sed -n "$startView,$endView p" <.commit/.$1.merging >.commit/.display.merge
			sed -i "${finishLocs[0]},${finishLocs[1]} s/.*/>>>> &/" .commit/.display.merge
			cat .commit/.display.merge | awk -v N=$startView -f awklinenumber
			
			printf "Do you want to add the following >>>> lines at line(s): ${finishLocs[0]}-${finishLocs[1]} (Y/n) ?\n "
			printf "\n"
			cat .commit/.display.merge 
		 	printf "\n"
			
			read -p "Enter (Y/n): " userAction
			case $userAction in
				[Yy])
					echo "adding"
					sed -ie "${finishLocs[0]}r .commit/.add.merge" .commit/$1
					;;
				[Nn])
					echo "not adding"
					loc=${finishLocs[0]}","${finishLocs[1]}"d"
					sed -i $loc .commit/.$1.merging
					;;
			esac

			;;
		"c")
			removeLocation=$(sed "2q;d" .commit/$1.changes)
			linesToRemove=$(sed "4q;d" .commit/$1.changes)
			addLocation=$(sed "3q;d" .commit/$1.changes)
			linesToAdd=$(sed "5q;d" .commit/$1.changes)
			printf "Do you want to change the following lines at lines(s): $removeLocation (Y/n)  \n ---------from --------- \n$linesToRemove\n ----------- to ----------- \n$linesToAdd\n"
			read userAction
			;;
		"d")
			;;
	esac

}

if [ $1 == 'add' -o $1 == '-a' ]; then
	add $2
elif [ $1 == 'list' -o $1 == '-l' ]; then
	list
elif [ $1 == 'commit' -o $1 == '-c' ]; then
	commit $2
fi


