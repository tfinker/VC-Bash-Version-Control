#!/bin/bash

if [[ $# -eq 0 ]];
then
	echo "No parameters provided"
	exit 0
fi

function add {

	if [[ -z $1 ]]; then
		echo "Add: No file provided"
		exit 0
	fi

	if [[ ! -f $1 ]]; then
		echo "Add: File '$1' doesn't exist"
		exit 0
	fi

	if [[ ! -d '.staging' ]]; then
		mkdir './.staging'
	fi
	cp $1 ./.staging/

	printf "$1 added to staging\n"
}

function list {
	printf "\n"
	exit=false
	while [[ $exit = false ]]; do
		printf "List files: Please select an option\n\t1: files in staging\n\t2: files in the last commit\n\t3: files in an older commit\n\t4: exit \nOption:  "
		read userAction
		printf "\n"
		case $userAction in
			"1") 
	
				printf "Files in staging \n"	
				printf "\n"
				if [[ -d './.staging' ]]; then
					index=0
					files=($(ls ./.staging))
					for line in ${files[@]}; do
						printf "\t- $index: $line\n"
				      		(( index = index+1 ))
					done
				else
					printf "\tNo files in staging\n"
				fi	
		
			
				printf "\n"
				;;
			"2")
				if [[ -d './.commit' ]]; then
					commits=($(ls .commit/ | sort -r))
					if [[ ! -z $commits ]];then
						files=($(ls .commit/${commits[0]}/))		
						index=0
						printf "Files in last commit '${commits[0]}':\n"
						for line in ${files[@]}; do
							printf "\t- $index: $line\n"
				      			(( index = index+1 ))
						done
					else
						printf "\tNo files in commit\n"
					fi
				else
					printf "\tNo files in commit\n"
				fi
				printf "\n"
				;;
			"3")
				if [[ -d './.commit' ]]; then
					commits=($(ls .commit/ | sort -r))
					if [[ ! -z $commits ]]; then
						printf "Select a commit to view: \n"
						index=1
						for commit in ${commits[@]}; do
							printf "\t$index: $commit\n"
							(( index = index+1 ))
						done
						read -p "Enter option: " userAction
						printf "\n"
						choice=$(( $userAction-1 ))
						files=($(ls .commit/${commits[$choice]}))
						printf "Files in commit '${commits[$choice]}':\n"
						index=0
						for file in $files; do
							printf "\t- $index: $file\n"
							(( index = index +1 ))
						done
						printf "\n"
					else
						printf "\tNo files in commit\n"
					fi
				else
					printf "\tNo files in commit\n"
				fi
				;;
			"4")
				exit=true
				;;	
			"*")
				printf "Wrong action entered\n"
				;;
		esac
	done
}

function commit {
#	echo 'commit function'

	if [[ ! -d ./.staging ]]; then
		echo "No files in staging"
		exit 0
	fi

	if [[ -z "$(ls -A ./.staging/)" ]]; then
		echo "No files in staging"
		exit 0
	fi

	if [[ -z $1 ]]; then
		echo "Commit: no message provided"
		exit 0
	fi
	
	commitDate=$(date)
	mkdir -p ./.commit
	commitDirs=($(ls ./.commit))
		
	lastCommit=0
	for commit in ${commitDirs[@]}; do

		result=$(cleanup $commit)
		if [[ $result == 'ready' ]]; then
			dir=${commit:1}
			if [[ $dir -gt $lastCommit ]]; then
				#echo "last commit $lastCommit dir $dir"
				lastCommit=$dir
			fi
		fi
	done

	if [[ $lastCommit -ne 0 ]]; then
#		echo "last commit found"
		commitNum=$(($lastCommit +1))
		commitName="c$commitNum"
		mkdir -p ./.commit/$commitName
		cp -r .commit/c$lastCommit/. ./.commit/$commitName/
	else
		commitName="c1"
		mkdir -p ./.commit/$commitName/
	fi
	
	stagingfiles=($(ls .staging))
	commitfiles=($(ls .commit/$commitName))
	echo "incomplete" > ./.commit/$commitName/.commitInfo
	
	printf "Creating new commit: $commitName \n"
	printf "Staged files: \n"
	for file in ${stagingfiles[@]};
	do
		printf "\t$file\n"
	done
	printf "\n"
	
	for file in ${stagingfiles[@]}
	do
		if [[ -f .commit/$commitName/$file ]]; then
			merge $file $commitName
		else		
			cp .staging/$file .commit/$commitName/
			printf "\t$file added to commit\n"
		fi
	done

	echo "Commit date: "$commitDate > ./.commit/$commitName/.commitInfo
	echo "Message: "$1 >> ./.commit/$commitName/.commitInfo
#	chmod 444 ./.commit/$commitName/
#	rm -r ./.staging
	echo "Commit complete"
}

function cleanup {

	status=($(cat ./.commit/$1/.commitInfo))
	if [[ ${status[0]} == 'incomplete' ]]; then
		rm -r .commit/$1
		echo 'incomplete'
	else
		echo 'ready'
	fi

}

function merge {
	
	printf "File '$1' exists in last commit "
	compare=$(diff -q .staging/$1 .commit/$2/$1)
	if [[ $compare == "" ]]; then
		echo "and the files are identical"
	else
		echo "but the files are not identical"
	fi

	mergeComplete="false"
	while [[ $mergeComplete != true ]]; do
		printf "Do you want to overwrite (1) or merge (2) '$1' ? "
		read userAction

		case $userAction in
			"1")
				cp .staging/$1 .commit/$2/$1
				mergeComplete=true
				echo "File $1 overwritten"
				;;
			"2")
				printf "Merging $1\n"
				printf "\n"
				# create a copy of the staging file
				# process will iteratively align the commit file and the staging file until there
				# are no differences left between the two
				cp .staging/$1 .commit/$2/.$1.merging
				compare=$(diff -q .commit/$2/.$1.merging .commit/$2/$1)
				while [[ $compare != ""  ]]; do
					diff ".commit/$2/$1" ".commit/$2/.$1.merging" | awk -f awkdiff
					mergeAction=$(sed "1q;d" .commit/.action.merge)
					blockMerge $1 $2 $mergeAction 
					compare=$(diff -q .commit/$2/.$1.merging .commit/$2/$1)
					rm -f ./.commit/.action.merge
					rm -f ./.commit/.start.merge
					rm -f ./.commit/.finish.merge
					rm -f ./.commit/.add.merge
					rm -f ./.commit/.remove.merge
					rm -f ./.commit/.display.merge
				done
 				rm -f .commit/$2/.$1.merging
				mergeComplete=true
				echo "Merge complete"
				;;
			*)
				echo 'Wrong action entered'
				;;
		esac
	done
}


function blockMerge {
	case $3 in 
		"a")
			finishLocs=($(sed -n "1,2p" .commit/.finish.merge))

			printf "Do you want to add the following lines at line(s): ${finishLocs[0]}-${finishLocs[1]} (Y/n) ?\n "
			printf "\n"
			cat .commit/.display.merge 
		 	printf "\n"
			
			read -p "Enter (Y/n): " userAction
			case $userAction in
				[Yy])
			
					lines=($(wc -l .commit/$2/$1))
					if test ${lines[0]} -lt ${finishLocs[0]}; then
						cat .commit/.add.merge >> .commit/$2/$1
					else			
						cat .commit/.add.merge | sed -i ${finishLocs[0]}'e cat /dev/stdin' .commit/$2/$1
					fi
					;;
				[Nn])
					loc=${finishLocs[0]}","${finishLocs[1]}"d"
					sed -i $loc .commit/$2/.$1.merging
					;;
			esac

			;;
		"c")

			startLocs=($(sed -n "1,2p" .commit/.start.merge))
			finishLocs=($(sed -n "1,2p" .commit/.finish.merge))	
		
			printf "Do you want to replace the following lines at line(s): ${startLocs[0]}-${startLocs[1]} (Y/n) ?\n "
			printf "\n"
			cat .commit/.display.merge
			printf "\n"
		
			read -p "Enter (Y/n): " userAction
			case $userAction in 
				[Yy])
					
					sed -i "${startLocs[0]},${startLocs[1]}d" .commit/$2/$1
					lines=($(wc -l .commit/$2/$1))
					if test ${lines[0]} -lt ${finishLocs[0]}; then
						cat .commit/.add.merge >> .commit/$2/$1
					else			
						cat .commit/.add.merge | sed -i ${finishLocs[0]}'e cat /dev/stdin' .commit/$2/$1
					fi
					;;
				[Nn])
					sed -i "${finishLocs[0]},${finishLocs[1]}d" .commit/$2/.$1.merging
					lines=($(wc -l .commit/$2/.$1.merging))
					if test ${lines[0]} -lt ${startLocs[0]}; then
						cat .commit/.remove.merge >> .commit/$2/.$1.merging
					else			
						cat .commit/.remove.merge | sed -i ${startLocs[0]}'e cat /dev/stdin' .commit/$2/.$1.merging
					fi
					;;
			esac
			;;
		"d")
			startLocs=($(sed -n "1,2p" .commit/.start.merge))
			finishLocs=($(sed -n "1,2p" .commit/.finish.merge))	
			printf "Do you want to delete the following lines at line(s): ${startLocs[0]}-${startLocs[1]} (Y/n) ?\n "
			printf "\n"
			cat .commit/.display.merge
			printf "\n"
		
			read -p "Enter (Y/n): " userAction
			case $userAction in 
				[Yy])
					sed -i "${startLocs[0]},${startLocs[1]}d" .commit/$2/$1
					;;
				[Nn])
					lines=($(wc -l .commit/$2/.$1.merging))
					if test ${lines[0]} -lt ${startLocs[0]}; then
						cat .commit/.remove.merge >> .commit/$2/.$1.merging
					else			
						cat .commit/.remove.merge | sed -i ${startLocs[0]}'e cat /dev/stdin' .commit/$2/.$1.merging
					fi
					;;
			esac
			;;
			
			
	esac

}

if [ $1 == 'add' -o $1 == '-a' ]; then
	add $2
elif [ $1 == 'list' -o $1 == '-l' ]; then
	list
elif [ $1 == 'commit' -o $1 == '-c' ]; then
	commit $2
fi


